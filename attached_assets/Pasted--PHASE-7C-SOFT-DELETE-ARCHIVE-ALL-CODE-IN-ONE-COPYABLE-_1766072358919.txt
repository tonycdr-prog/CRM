/* 
PHASE 7C — SOFT DELETE + ARCHIVE (ALL CODE IN ONE COPYABLE BLOCK)

WHAT THIS DOES
- Adds archivedAt columns to: entities, entityRows, formTemplates
- Updates API list endpoints to exclude archived by default (include with ?includeArchived=true)
- Replaces DELETE with ARCHIVE (safe for historical inspections/PDFs)
- Prevents adding archived entities to templates
- Prevents using archived templates for new inspections (and hides them in job forms list unless explicitly included)
- Updates Admin UI to use “Archive” + “Show archived” toggle

NOTE: You will still need to run your Drizzle migration after updating schema.ts.

────────────────────────────────────────────────────────────────────────────
A) shared/schema.ts — ADD archivedAt columns
────────────────────────────────────────────────────────────────────────────
Edit your existing tables (NOT new ones). Add archivedAt to each.

1) entities table:
- add: archivedAt: timestamp("archived_at", { withTimezone: true }),

2) entityRows table:
- add: archivedAt: timestamp("archived_at", { withTimezone: true }),

3) formTemplates table:
- add: archivedAt: timestamp("archived_at", { withTimezone: true }),

Example (illustrative — merge into your existing table definitions):

export const entities = pgTable("entities", {
  ...
  archivedAt: timestamp("archived_at", { withTimezone: true }),
});

export const entityRows = pgTable("entity_rows", {
  ...
  archivedAt: timestamp("archived_at", { withTimezone: true }),
});

export const formTemplates = pgTable("form_templates", {
  ...
  archivedAt: timestamp("archived_at", { withTimezone: true }),
});

After this: generate + run migration.

────────────────────────────────────────────────────────────────────────────
B) server/routes.ts — UPDATE LIST ENDPOINTS + REPLACE DELETE WITH ARCHIVE
────────────────────────────────────────────────────────────────────────────
Assumes:
- requireOrgRole(req, ["owner","admin"]) exists
- requireUserOrgId(req) exists
- Your tables are imported: entities, entityRows, formTemplates, formTemplateEntities, formTemplateSystemTypes
- Drizzle helpers imported: and, eq, isNull, sql, inArray, desc
If you don’t already import isNull, add:
import { and, eq, isNull, inArray, desc, sql } from "drizzle-orm";

1) ADMIN ENTITIES: GET /api/admin/entities (exclude archived unless includeArchived=true)
REPLACE your existing GET handler with:

apiRouter.get("/admin/entities", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const includeArchived = String(req.query?.includeArchived || "") === "true";

  const whereClause = includeArchived
    ? eq(entities.organizationId, auth.organizationId)
    : and(eq(entities.organizationId, auth.organizationId), isNull(entities.archivedAt));

  const list = await db
    .select({
      id: entities.id,
      title: entities.title,
      description: entities.description,
      archivedAt: (entities as any).archivedAt,
      createdAt: entities.createdAt,
      updatedAt: entities.updatedAt,
    })
    .from(entities)
    .where(whereClause)
    .orderBy(entities.title);

  res.json({ entities: list });
});

2) ADMIN ENTITY ROWS: GET /api/admin/entities/:id/rows (exclude archived unless includeArchived=true)
REPLACE your existing rows GET handler with:

apiRouter.get("/admin/entities/:id/rows", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const entityId = String(req.params.id || "");
  if (!entityId) return res.status(400).json({ message: "Invalid id" });

  const includeArchived = String(req.query?.includeArchived || "") === "true";

  const whereClause = includeArchived
    ? and(eq(entityRows.entityId, entityId), eq(entityRows.organizationId, auth.organizationId))
    : and(
        eq(entityRows.entityId, entityId),
        eq(entityRows.organizationId, auth.organizationId),
        isNull(entityRows.archivedAt)
      );

  const rows = await db
    .select({
      id: entityRows.id,
      entityId: entityRows.entityId,
      sortOrder: entityRows.sortOrder,
      component: entityRows.component,
      activity: entityRows.activity,
      reference: entityRows.reference,
      fieldType: entityRows.fieldType,
      units: entityRows.units,
      choices: entityRows.choices,
      evidenceRequired: entityRows.evidenceRequired,
      archivedAt: (entityRows as any).archivedAt,
    })
    .from(entityRows)
    .where(whereClause)
    .orderBy(entityRows.sortOrder);

  res.json({ rows });
});

3) ADMIN TEMPLATES: GET /api/admin/templates (exclude archived unless includeArchived=true)
REPLACE your existing GET handler with:

apiRouter.get("/admin/templates", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const includeArchived = String(req.query?.includeArchived || "") === "true";

  const whereClause = includeArchived
    ? eq(formTemplates.organizationId, auth.organizationId)
    : and(eq(formTemplates.organizationId, auth.organizationId), isNull(formTemplates.archivedAt));

  const list = await db
    .select({
      id: formTemplates.id,
      name: formTemplates.name,
      description: formTemplates.description,
      isActive: formTemplates.isActive,
      archivedAt: (formTemplates as any).archivedAt,
      createdAt: formTemplates.createdAt,
      updatedAt: formTemplates.updatedAt,
    })
    .from(formTemplates)
    .where(whereClause)
    .orderBy(formTemplates.name);

  res.json({ templates: list });
});

4) REPLACE DELETE endpoints with ARCHIVE endpoints

4a) Entities: DELETE /api/admin/entities/:id  -> ARCHIVE
REPLACE your delete handler with:

apiRouter.delete("/admin/entities/:id", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const entityId = String(req.params.id || "");
  if (!entityId) return res.status(400).json({ message: "Invalid id" });

  const now = new Date();

  // archive all rows too
  await db
    .update(entityRows)
    .set({ archivedAt: now, updatedAt: now })
    .where(and(eq(entityRows.entityId, entityId), eq(entityRows.organizationId, auth.organizationId)));

  const updated = await db
    .update(entities)
    .set({ archivedAt: now, updatedAt: now })
    .where(and(eq(entities.id, entityId), eq(entities.organizationId, auth.organizationId)))
    .returning({ id: entities.id });

  if (!updated.length) return res.status(404).json({ message: "Not found" });

  // Optional: remove from templates so it can’t be used going forward
  await db
    .delete(formTemplateEntities)
    .where(and(eq(formTemplateEntities.entityId, entityId), eq(formTemplateEntities.organizationId, auth.organizationId)));

  res.json({ ok: true, archivedAt: now.toISOString() });
});

4b) Entity rows: DELETE /api/admin/entity-rows/:rowId -> ARCHIVE
REPLACE your delete row handler with:

apiRouter.delete("/admin/entity-rows/:rowId", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const rowId = String(req.params.rowId || "");
  if (!rowId) return res.status(400).json({ message: "Invalid rowId" });

  const now = new Date();
  const updated = await db
    .update(entityRows)
    .set({ archivedAt: now, updatedAt: now })
    .where(and(eq(entityRows.id, rowId), eq(entityRows.organizationId, auth.organizationId)))
    .returning({ id: entityRows.id });

  if (!updated.length) return res.status(404).json({ message: "Not found" });
  res.json({ ok: true, archivedAt: now.toISOString() });
});

4c) Templates: DELETE /api/admin/templates/:id -> ARCHIVE
REPLACE your delete template handler with:

apiRouter.delete("/admin/templates/:id", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  if (!templateId) return res.status(400).json({ message: "Invalid id" });

  const now = new Date();

  // Archive template (keep mappings for history; future forms will exclude archived templates)
  const updated = await db
    .update(formTemplates)
    .set({ archivedAt: now, isActive: false, updatedAt: now })
    .where(and(eq(formTemplates.id, templateId), eq(formTemplates.organizationId, auth.organizationId)))
    .returning({ id: formTemplates.id });

  if (!updated.length) return res.status(404).json({ message: "Not found" });

  res.json({ ok: true, archivedAt: now.toISOString() });
});

5) Prevent adding archived entity to template (POST /api/admin/templates/:id/entities)
PATCH your handler before insert:
- ensure entity.archivedAt is null

Find the validation query and change it to:

const ent = await db
  .select({ id: entities.id, archivedAt: (entities as any).archivedAt })
  .from(entities)
  .where(and(eq(entities.id, entityId), eq(entities.organizationId, auth.organizationId)))
  .limit(1);
if (!ent.length) return res.status(404).json({ message: "Entity not found" });
if (ent[0].archivedAt) return res.status(409).json({ message: "Entity is archived" });

6) Ensure job forms list excludes archived templates (where you build template lists for engineers)
In your existing endpoint like:
GET /api/jobs/:jobId/forms   (or similar)
ensure templates query includes:
- isNull(formTemplates.archivedAt)
- AND formTemplates.isActive = true (recommended)

Example filter:
.where(
  and(
    eq(formTemplates.organizationId, organizationId),
    isNull(formTemplates.archivedAt),
    eq(formTemplates.isActive, true),
    ...other joins/filters...
  )
)

────────────────────────────────────────────────────────────────────────────
C) CLIENT — Admin UI “Show archived” + “Archive” label changes
────────────────────────────────────────────────────────────────────────────

1) client/src/pages/admin/entities.tsx
- Add a checkbox “Show archived”
- Pass query param includeArchived=true to /api/admin/entities
- Label the delete button as “Archive” (or remove delete from list view)

PATCH (merge into your existing AdminEntitiesPage):

// add state:
const [showArchived, setShowArchived] = useState(false);

// in load():
const url = `/api/admin/entities${showArchived ? "?includeArchived=true" : ""}`;
// fetch(url)

// add UI near search input:
<div className="flex items-center gap-2">
  <input
    type="checkbox"
    checked={showArchived}
    onChange={(e) => setShowArchived(e.target.checked)}
  />
  <span className="text-sm">Show archived</span>
</div>

// ensure useEffect reruns when showArchived changes:
useEffect(() => { load(); }, [showArchived]);

2) client/src/pages/admin/entity-edit.tsx
- Change “Delete” button text to “Archive”
(no code change required because endpoint is still DELETE, but semantics are archive now)
- Optionally show archived status if entity.archivedAt present (from list fetch)

Change button label only:
<Button variant="destructive" onClick={deleteEntity} disabled={saving}>
  Archive
</Button>

3) client/src/pages/admin/templates.tsx
- Same “Show archived” toggle
- Fetch /api/admin/templates?includeArchived=true when toggled

Add:
const [showArchived, setShowArchived] = useState(false);
const url = `/api/admin/templates${showArchived ? "?includeArchived=true" : ""}`;
useEffect(() => { load(); }, [showArchived]);

Add checkbox UI near search.

4) client/src/pages/admin/template-edit.tsx
- Change “Delete” button text to “Archive”
(because DELETE now archives)
<Button variant="destructive" ...>Archive</Button>

────────────────────────────────────────────────────────────────────────────
D) TEST CHECKLIST
────────────────────────────────────────────────────────────────────────────
1) Archive an Entity:
- It disappears from Entities list (default)
- It appears when “Show archived” checked
- It cannot be added to templates (409 “Entity is archived”)
- Existing inspections/PDFs still work (because inspections store template + row IDs; you did not delete)

2) Archive a Template:
- It disappears from Templates list (default)
- It appears when showArchived
- Field Companion job forms list does NOT show it (archivedAt != null and isActive false)

3) Archived rows:
- Rows list excludes them by default
- Existing inspections/PDF still render (rows may be archived but still present)

If you want the next safety step:
PHASE 7C.1 — “Prevent archiving if used by completed inspection” (harder rule)
Say “7C.1”.
*/