// ─────────────────────────────────────────────
// PDF EXPORT (AUTH)
// ─────────────────────────────────────────────
apiRouter.get("/inspections/:id/pdf", async (req, res) => {
  const { organizationId } = await requireUserOrgId(req);
  const inspectionId = String(req.params.id || "");
  if (!inspectionId) return res.status(400).json({ message: "Invalid inspection id" });

  const insp = await db
    .select({
      id: inspectionInstances.id,
      jobId: inspectionInstances.jobId,
      templateId: inspectionInstances.templateId,
      systemTypeId: inspectionInstances.systemTypeId,
      completedAt: inspectionInstances.completedAt,
    })
    .from(inspectionInstances)
    .where(and(eq(inspectionInstances.id, inspectionId), eq(inspectionInstances.organizationId, organizationId)))
    .limit(1);

  if (!insp.length) return res.status(404).json({ message: "Inspection not found" });
  if (!insp[0].completedAt) return res.status(409).json({ message: "Inspection not completed" });

  // Ensure job belongs to org (your Phase 2 helper)
  const access = await requireJobInOrg(String(insp[0].jobId), organizationId);
  if (!access.ok) return res.status(access.status).json({ message: access.message });

  // Template name
  const tpl = await db
    .select({ id: formTemplates.id, name: formTemplates.name })
    .from(formTemplates)
    .where(and(eq(formTemplates.id, insp[0].templateId), eq(formTemplates.organizationId, organizationId)))
    .limit(1);
  if (!tpl.length) return res.status(404).json({ message: "Template not found" });

  // System type name
  const sys = await db
    .select({ id: systemTypes.id, name: systemTypes.name })
    .from(systemTypes)
    .where(and(eq(systemTypes.id, insp[0].systemTypeId), eq(systemTypes.organizationId, organizationId)))
    .limit(1);
  if (!sys.length) return res.status(404).json({ message: "System type not found" });

  // Ordered entities on template
  const te = await db
    .select({
      entityId: formTemplateEntities.entityId,
      sortOrder: formTemplateEntities.sortOrder,
      title: entities.title,
      description: entities.description,
    })
    .from(formTemplateEntities)
    .innerJoin(entities, eq(entities.id, formTemplateEntities.entityId))
    .where(and(eq(formTemplateEntities.templateId, insp[0].templateId), eq(formTemplateEntities.organizationId, organizationId)))
    .orderBy(formTemplateEntities.sortOrder);

  const entityIds = te.map((x) => x.entityId);

  const rows = entityIds.length
    ? await db
        .select({
          id: entityRows.id,
          entityId: entityRows.entityId,
          sortOrder: entityRows.sortOrder,
          component: entityRows.component,
          activity: entityRows.activity,
          reference: entityRows.reference,
          fieldType: entityRows.fieldType,
          units: entityRows.units,
          evidenceRequired: entityRows.evidenceRequired,
        })
        .from(entityRows)
        .where(and(eq(entityRows.organizationId, organizationId), inArray(entityRows.entityId, entityIds)))
        .orderBy(entityRows.entityId, entityRows.sortOrder)
    : [];

  // Latest responses per row
  const resp = await db
    .select({
      rowId: inspectionResponses.rowId,
      valueText: inspectionResponses.valueText,
      valueNumber: inspectionResponses.valueNumber,
      valueBool: inspectionResponses.valueBool,
      comment: inspectionResponses.comment,
      createdAt: inspectionResponses.createdAt,
    })
    .from(inspectionResponses)
    .where(and(eq(inspectionResponses.organizationId, organizationId), eq(inspectionResponses.inspectionId, inspectionId)))
    .orderBy(desc(inspectionResponses.createdAt));

  const latestByRow = new Map<string, any>();
  for (const r of resp) {
    if (!latestByRow.has(r.rowId)) latestByRow.set(r.rowId, r);
  }

  // Attachments (names only for PDF)
  const atts = await db
    .select({
      rowId: inspectionRowAttachments.rowId,
      originalName: files.originalName,
    })
    .from(inspectionRowAttachments)
    .innerJoin(files, eq(files.id, inspectionRowAttachments.fileId))
    .where(and(eq(inspectionRowAttachments.organizationId, organizationId), eq(inspectionRowAttachments.inspectionId, inspectionId)))
    .orderBy(desc(inspectionRowAttachments.createdAt));

  const attachmentsByRowId = new Map<string, Array<{ originalName: string }>>();
  for (const a of atts) {
    const list = attachmentsByRowId.get(a.rowId) ?? [];
    list.push({ originalName: a.originalName });
    attachmentsByRowId.set(a.rowId, list);
  }

  const payload = {
    inspectionId,
    templateName: tpl[0].name,
    systemTypeName: sys[0].name,
    jobId: String(insp[0].jobId),
    completedAt: new Date(insp[0].completedAt as any).toISOString(),
    entities: te.map((e) => ({
      title: e.title,
      description: e.description ?? null,
      rows: rows
        .filter((r) => r.entityId === e.entityId)
        .map((r) => {
          const lr = latestByRow.get(r.id);
          let value = "—";
          if (lr) {
            if (lr.valueBool === true) value = "Pass";
            else if (lr.valueBool === false) value = "Fail";
            else if (lr.valueNumber) value = String(lr.valueNumber);
            else if (lr.valueText) value = String(lr.valueText);
          }
          return {
            component: r.component,
            activity: r.activity,
            reference: r.reference ?? null,
            fieldType: String(r.fieldType),
            units: r.units ?? null,
            evidenceRequired: !!r.evidenceRequired,
            value,
            comment: lr?.comment ?? null,
            attachments: attachmentsByRowId.get(r.id) ?? [],
          };
        }),
    })),
  };

  const doc = buildInspectionPdf(payload);

  const filenameSafe = `${payload.jobId}_${payload.templateName}`.replace(/[^a-zA-Z0-9._-]/g, "_");
  res.setHeader("Content-Type", "application/pdf");
  res.setHeader("Content-Disposition", `attachment; filename="${filenameSafe}.pdf"`);

  doc.pipe(res);
  doc.end();
});