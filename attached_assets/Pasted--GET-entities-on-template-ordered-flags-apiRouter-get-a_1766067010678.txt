// GET entities on template (ordered) + flags
apiRouter.get("/admin/templates/:id/entities", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  if (!templateId) return res.status(400).json({ message: "Invalid id" });

  const rows = await db
    .select({
      entityId: formTemplateEntities.entityId,
      sortOrder: formTemplateEntities.sortOrder,
      required: formTemplateEntities.required,
      repeatPerAsset: formTemplateEntities.repeatPerAsset,
      evidenceRequired: formTemplateEntities.evidenceRequired,
      title: entities.title,
      description: entities.description,
    })
    .from(formTemplateEntities)
    .innerJoin(entities, eq(entities.id, formTemplateEntities.entityId))
    .where(and(eq(formTemplateEntities.templateId, templateId), eq(formTemplateEntities.organizationId, auth.organizationId)))
    .orderBy(formTemplateEntities.sortOrder);

  res.json({ entities: rows });
});

// Add entity to template
apiRouter.post("/admin/templates/:id/entities", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  const entityId = String(req.body?.entityId || "");
  if (!templateId || !entityId) return res.status(400).json({ message: "templateId and entityId required" });

  // validate entity belongs to org
  const ent = await db
    .select({ id: entities.id })
    .from(entities)
    .where(and(eq(entities.id, entityId), eq(entities.organizationId, auth.organizationId)))
    .limit(1);
  if (!ent.length) return res.status(404).json({ message: "Entity not found" });

  const max = await db
    .select({ max: sql<number>`coalesce(max(${formTemplateEntities.sortOrder}),0)` })
    .from(formTemplateEntities)
    .where(and(eq(formTemplateEntities.templateId, templateId), eq(formTemplateEntities.organizationId, auth.organizationId)));

  const nextSort = (max[0]?.max ?? 0) + 1;

  const created = await db
    .insert(formTemplateEntities)
    .values({
      organizationId: auth.organizationId,
      templateId,
      entityId,
      sortOrder: nextSort,
      required: true,
      repeatPerAsset: false,
      evidenceRequired: false,
    })
    .returning({
      templateId: formTemplateEntities.templateId,
      entityId: formTemplateEntities.entityId,
      sortOrder: formTemplateEntities.sortOrder,
      required: formTemplateEntities.required,
      repeatPerAsset: formTemplateEntities.repeatPerAsset,
      evidenceRequired: formTemplateEntities.evidenceRequired,
    });

  res.json({ mapping: created[0] });
});

// Update flags for a template entity mapping
apiRouter.patch("/admin/templates/:id/entities/:entityId", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  const entityId = String(req.params.entityId || "");
  if (!templateId || !entityId) return res.status(400).json({ message: "Invalid id" });

  const patch: any = {};
  if (typeof req.body?.required === "boolean") patch.required = req.body.required;
  if (typeof req.body?.repeatPerAsset === "boolean") patch.repeatPerAsset = req.body.repeatPerAsset;
  if (typeof req.body?.evidenceRequired === "boolean") patch.evidenceRequired = req.body.evidenceRequired;

  const updated = await db
    .update(formTemplateEntities)
    .set(patch)
    .where(
      and(
        eq(formTemplateEntities.templateId, templateId),
        eq(formTemplateEntities.entityId, entityId),
        eq(formTemplateEntities.organizationId, auth.organizationId)
      )
    )
    .returning({
      templateId: formTemplateEntities.templateId,
      entityId: formTemplateEntities.entityId,
      sortOrder: formTemplateEntities.sortOrder,
      required: formTemplateEntities.required,
      repeatPerAsset: formTemplateEntities.repeatPerAsset,
      evidenceRequired: formTemplateEntities.evidenceRequired,
    });

  if (!updated.length) return res.status(404).json({ message: "Not found" });
  res.json({ mapping: updated[0] });
});

// Delete entity from template
apiRouter.delete("/admin/templates/:id/entities/:entityId", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  const entityId = String(req.params.entityId || "");
  if (!templateId || !entityId) return res.status(400).json({ message: "Invalid id" });

  const deleted = await db
    .delete(formTemplateEntities)
    .where(
      and(
        eq(formTemplateEntities.templateId, templateId),
        eq(formTemplateEntities.entityId, entityId),
        eq(formTemplateEntities.organizationId, auth.organizationId)
      )
    )
    .returning({ templateId: formTemplateEntities.templateId });

  if (!deleted.length) return res.status(404).json({ message: "Not found" });
  res.json({ ok: true });
});

// Reorder entities on template
apiRouter.post("/admin/templates/:id/entities/reorder", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner", "admin"]);
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const templateId = String(req.params.id || "");
  if (!templateId) return res.status(400).json({ message: "Invalid id" });

  const orderedEntityIds = Array.isArray(req.body?.orderedEntityIds) ? req.body.orderedEntityIds : [];
  if (!orderedEntityIds.length) return res.status(400).json({ message: "orderedEntityIds[] required" });

  const existing = await db
    .select({ entityId: formTemplateEntities.entityId })
    .from(formTemplateEntities)
    .where(and(eq(formTemplateEntities.templateId, templateId), eq(formTemplateEntities.organizationId, auth.organizationId)));

  const set = new Set(existing.map((x) => x.entityId));
  for (const id of orderedEntityIds) {
    if (!set.has(id)) return res.status(400).json({ message: `Invalid entityId: ${id}` });
  }

  await db.transaction(async (tx) => {
    for (let i = 0; i < orderedEntityIds.length; i++) {
      await tx
        .update(formTemplateEntities)
        .set({ sortOrder: i + 1 })
        .where(
          and(
            eq(formTemplateEntities.templateId, templateId),
            eq(formTemplateEntities.entityId, orderedEntityIds[i]),
            eq(formTemplateEntities.organizationId, auth.organizationId)
          )
        );
    }
  });

  res.json({ ok: true });
});