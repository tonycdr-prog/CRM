/*
PHASE 11D + 11E + 11F — MOBILE FIELD POLISH (ALL IN ONE COPYABLE BLOCK)

11D) Camera UX preview + retake (before upload)
11E) Background sync queue + progress UI (flushQueue progress + auto retry)
11F) Native wrapper option (Capacitor) + minimal config (so you can ship to stores later)

ASSUMES
- You already have offlineQueue.ts with flushQueue({ onProgress }) from Phase 6B
- You already have an evidence upload function uploadEvidence(rowId, file)
- You have shadcn Button/Card (or replace with your UI)
- You are OK with a simple modal using basic divs (no extra deps)

──────────────────────────────────────────────────────────────
11D) CAMERA PREVIEW + RETAKE
FILES:
- client/src/components/CapturePreviewModal.tsx (NEW)
- client/src/components/ImageCaptureInput.tsx (MODIFY)
- client/src/lib/image.ts (MODIFY: add blobToFile helper)
──────────────────────────────────────────────────────────────
*/

// ============================================================
// client/src/lib/image.ts (MODIFY) — add blobToFile
// ============================================================
export function blobToFile(blob: Blob, fileName: string) {
  return new File([blob], fileName, { type: (blob as any).type || "application/octet-stream" });
}

// ============================================================
// client/src/components/CapturePreviewModal.tsx (NEW)
// ============================================================
import React from "react";
import { Button } from "@/components/ui/button";

export default function CapturePreviewModal(props: {
  open: boolean;
  previewUrl: string | null;
  fileType: string | null;
  onRetake: () => void;
  onConfirm: () => void;
  onClose: () => void;
}) {
  if (!props.open) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center p-4">
      <div className="bg-background rounded-lg w-full max-w-md p-4 space-y-3">
        <div className="font-semibold">Preview</div>

        <div className="border rounded-md overflow-hidden">
          {props.fileType?.startsWith("image/") && props.previewUrl ? (
            <img src={props.previewUrl} alt="preview" className="w-full h-auto" />
          ) : (
            <div className="p-6 text-sm text-muted-foreground">No preview available</div>
          )}
        </div>

        <div className="flex gap-2 justify-end">
          <Button variant="outline" onClick={props.onRetake}>Retake</Button>
          <Button variant="outline" onClick={props.onClose}>Cancel</Button>
          <Button onClick={props.onConfirm}>Use this</Button>
        </div>
      </div>
    </div>
  );
}

// ============================================================
// client/src/components/ImageCaptureInput.tsx (MODIFY) — add preview+retake flow
// ============================================================
import React, { useMemo, useState } from "react";
import { compressImage, blobToFile } from "@/lib/image";
import CapturePreviewModal from "@/components/CapturePreviewModal";
import { Button } from "@/components/ui/button";

export default function ImageCaptureInput(props: {
  onFileReady: (file: File) => void;
  disabled?: boolean;
  label?: string;
}) {
  const { onFileReady, disabled } = props;

  const [pendingBlob, setPendingBlob] = useState<Blob | null>(null);
  const [pendingType, setPendingType] = useState<string | null>(null);
  const [open, setOpen] = useState(false);
  const previewUrl = useMemo(() => (pendingBlob ? URL.createObjectURL(pendingBlob) : null), [pendingBlob]);

  async function handlePicked(file: File) {
    let blob: Blob = file;

    if (file.type.startsWith("image/")) {
      blob = await compressImage(file);
    }

    setPendingBlob(blob);
    setPendingType(file.type || (blob as any).type || null);
    setOpen(true);
  }

  function cleanup() {
    if (previewUrl) URL.revokeObjectURL(previewUrl);
    setPendingBlob(null);
    setPendingType(null);
  }

  function onConfirm() {
    if (!pendingBlob) return;
    const f = blobToFile(pendingBlob, `capture_${Date.now()}.jpg`);
    cleanup();
    setOpen(false);
    onFileReady(f);
  }

  function onRetake() {
    cleanup();
    setOpen(false);
    // the user can tap capture again
  }

  return (
    <div className="flex items-center gap-2">
      <label className="inline-flex items-center">
        <input
          type="file"
          accept="image/*,application/pdf"
          capture="environment"
          disabled={disabled}
          className="hidden"
          onChange={async (e) => {
            const file = e.target.files?.[0];
            e.target.value = "";
            if (!file) return;
            await handlePicked(file);
          }}
        />
        <Button type="button" variant="outline" disabled={disabled}>
          {props.label ?? "Add photo"}
        </Button>
      </label>

      <CapturePreviewModal
        open={open}
        previewUrl={previewUrl}
        fileType={pendingType}
        onRetake={onRetake}
        onConfirm={onConfirm}
        onClose={() => {
          cleanup();
          setOpen(false);
        }}
      />
    </div>
  );
}

/*
INTEGRATE:
- Wherever you previously rendered a file input for evidence, use:
  <ImageCaptureInput onFileReady={(file)=>uploadEvidence(rowId,file)} />
*/

////////////////////////////////////////////////////////////////
// 11E) BACKGROUND SYNC QUEUE + PROGRESS UI
FILES:
- client/src/hooks/useSyncQueue.ts (NEW)
- client/src/components/SyncStatusBar.tsx (NEW)
- Integrate into Field Companion root/layout (MODIFY)
////////////////////////////////////////////////////////////////

// ============================================================
// client/src/hooks/useSyncQueue.ts (NEW)
// ============================================================
import { useEffect, useRef, useState } from "react";
import { flushQueue, getPendingCount } from "@/lib/offlineQueue";

export function useSyncQueue(opts?: { inspectionId?: string }) {
  const [pending, setPending] = useState(0);
  const [syncing, setSyncing] = useState(false);
  const [progress, setProgress] = useState({ sent: 0, remaining: 0 });
  const timer = useRef<number | null>(null);

  async function refresh() {
    const c = await getPendingCount(opts?.inspectionId);
    setPending(c);
  }

  async function syncNow() {
    if (syncing) return;
    if (!navigator.onLine) return;

    setSyncing(true);
    setProgress({ sent: 0, remaining: pending });

    await flushQueue({
      onProgress: (sent, remaining) => setProgress({ sent, remaining }),
    });

    setSyncing(false);
    await refresh();
  }

  useEffect(() => {
    refresh();
    const onOnline = () => syncNow();
    window.addEventListener("online", onOnline);

    // Poll pending count every 5s while app is open
    timer.current = window.setInterval(() => refresh(), 5000) as any;

    return () => {
      window.removeEventListener("online", onOnline);
      if (timer.current) window.clearInterval(timer.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [opts?.inspectionId]);

  return { pending, syncing, progress, refresh, syncNow };
}

// ============================================================
// client/src/components/SyncStatusBar.tsx (NEW)
// ============================================================
import { Button } from "@/components/ui/button";

export default function SyncStatusBar(props: {
  pending: number;
  syncing: boolean;
  progress: { sent: number; remaining: number };
  onSyncNow: () => void;
}) {
  const { pending, syncing, progress } = props;

  if (pending <= 0 && !syncing) return null;

  const total = progress.sent + progress.remaining;
  const pct = total > 0 ? Math.round((progress.sent / total) * 100) : 0;

  return (
    <div className="fixed top-0 left-0 right-0 z-50 bg-background border-b p-2 flex items-center justify-between gap-2">
      <div className="text-sm">
        {syncing ? (
          <span>Syncing… {progress.sent}/{total} ({pct}%)</span>
        ) : (
          <span>Pending sync items: {pending}</span>
        )}
      </div>
      <Button variant="outline" size="sm" onClick={props.onSyncNow} disabled={syncing || !navigator.onLine}>
        Sync now
      </Button>
    </div>
  );
}

/*
INTEGRATE (Field Companion root/layout or field-job-forms page):
- import { useSyncQueue } from "@/hooks/useSyncQueue";
- import SyncStatusBar from "@/components/SyncStatusBar";

In component:
  const { pending, syncing, progress, syncNow } = useSyncQueue({ inspectionId: inspection?.id });

Render once:
  <SyncStatusBar pending={pending} syncing={syncing} progress={progress} onSyncNow={syncNow} />

This gives background retry on online + manual sync + progress.
*/

////////////////////////////////////////////////////////////////
// 11F) NATIVE WRAPPER (CAPACITOR) — OPTIONAL SETUP
////////////////////////////////////////////////////////////////
/*
This is scaffolding, not required to run web app.

INSTALL:
  npm i @capacitor/core @capacitor/cli
  npx cap init "Life Safety Ops" "com.lifesafety.ops" --web-dir=dist

BUILD:
  npm run build
  npx cap add ios
  npx cap add android
  npx cap sync

NOTES:
- Your PWA is already installable; Capacitor is for App Store distribution.
- For camera/file system, Capacitor plugins can be added later:
  npm i @capacitor/camera @capacitor/filesystem
*/

////////////////////////////////////////////////////////////////
// QUICK TEST
////////////////////////////////////////////////////////////////
/*
11D:
- Tap “Add photo”
- Take photo
- Preview modal shows image
- Retake returns to capture
- Use this uploads (or queues offline)

11E:
- Go offline, make changes/upload -> pending increases
- Go online -> auto sync starts
- Progress bar shows sent/total
*/