/*
PHASE 12 — IMPORT / RESTORE (SERVER-SIDE) WITH DRY-RUN + APPLY
ALL IN ONE COPYABLE BLOCK

NOTE:
You already implemented a strong CLI restore (10B.1). Phase 12 adds a *server-side* import endpoint
for owner/admin convenience, with:
- dry-run validation report
- apply mode (imports into NEW org by default)
- audit log event "org.imported"

SAFETY DEFAULTS
- Apply requires: targetOrgMode = "new" (creates a new org record) unless --explicitOverwrite=true
- This prevents accidental overwrite of live tenant data.

ASSUMES
- You have an organizations table OR you identify org solely by UUID referenced by users.
  If you do NOT have an organizations table, Phase 12 still works by creating plan/usage for the new org id
  and leaving user invitation to you.

- You already have auditEvents + logAudit helper.

DEPENDENCIES
- Uses zod for input validation. If you don’t have it:
  npm i zod

FILES:
- server/lib/importOrg.ts (NEW) — validation + apply logic
- server/routes.ts (MODIFY) — POST /api/admin/import
- shared/schema.ts (OPTIONAL) — import_jobs table to track import runs (nice-to-have; included)

──────────────────────────────────────────────────────────────
A) shared/schema.ts — OPTIONAL importRuns table
(If you don’t want this, skip section A and remove related inserts in section C)
──────────────────────────────────────────────────────────────
*/

export const importRuns = pgTable(
  "import_runs",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    organizationId: uuid("organization_id").notNull(), // target org
    sourceOrganizationId: uuid("source_organization_id"),
    mode: text("mode").notNull(), // "dry_run" | "apply"
    status: text("status").notNull().default("succeeded"), // succeeded | failed
    summary: jsonb("summary").$type<Record<string, any>>().default({}).notNull(),
    error: text("error"),
    createdByUserId: uuid("created_by_user_id").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    orgIdx: index("import_runs_org_idx").on(t.organizationId, t.createdAt),
  })
);

/*
Run migration if you add importRuns.

──────────────────────────────────────────────────────────────
B) server/lib/importOrg.ts (NEW)
──────────────────────────────────────────────────────────────
*/

import { z } from "zod";
import crypto from "crypto";
import { and, eq } from "drizzle-orm";
import { logAudit } from "./audit";

export const ImportPayloadSchema = z.object({
  manifest: z.any(), // we validate shape lightly below (keeps backward compatible)
  // apply options
  targetOrgId: z.string().uuid().optional(), // if omitted in apply, server will create a random new UUID
  mode: z.enum(["dry_run", "apply"]),
  explicitOverwrite: z.boolean().optional().default(false),
  // If your model needs job restore, keep false for now
  includeJobs: z.boolean().optional().default(false),
});

function countArr(x: any) {
  return Array.isArray(x) ? x.length : 0;
}

function newUuid() {
  return crypto.randomUUID();
}

export async function dryRunImport(db: any, source: any) {
  const m = source?.manifest ?? source;
  const summary = {
    sourceOrganizationId: m?.organizationId ?? null,
    exportedAt: m?.exportedAt ?? null,
    counts: {
      templates: countArr(m?.templates),
      entities: countArr(m?.entities),
      entityRows: countArr(m?.entityRows),
      templateEntities: countArr(m?.templateEntities),
      templateSystemTypes: countArr(m?.templateSystemTypes),
      inspections: countArr(m?.inspections),
      inspectionResponses: countArr(m?.inspectionResponses),
      files: countArr(m?.files),
      inspectionRowAttachments: countArr(m?.inspectionRowAttachments),
      auditEvents: countArr(m?.auditEvents),
      serverErrors: countArr(m?.serverErrors),
      jobs: countArr(m?.jobs),
      users: countArr(m?.users),
    },
    warnings: [] as string[],
  };

  // Warnings about common pitfalls
  if (summary.counts.jobs > 0) {
    summary.warnings.push("Jobs are present in export; server import currently skips jobs unless includeJobs=true and jobs are org-scoped.");
  }
  if (summary.counts.files > 0) {
    summary.warnings.push("This endpoint imports metadata only; use ZIP/CLI restore for attachment binaries.");
  }
  if (!m?.templates || !Array.isArray(m.templates)) {
    summary.warnings.push("No templates array found — export may be incomplete.");
  }
  return summary;
}

export async function applyImport(db: any, args: {
  auth: { organizationId: string; userId: string };
  payload: any;
}) {
  const parsed = ImportPayloadSchema.parse(args.payload);
  const m = parsed.payload?.manifest ?? parsed.manifest ?? parsed.payload ?? parsed; // tolerant
  const manifest = parsed.manifest ?? (parsed as any).manifest ?? m;

  const sourceOrgId = manifest?.organizationId ?? null;

  const targetOrgId = parsed.targetOrgId ?? newUuid();

  // Safety: refuse overwrite unless explicitOverwrite=true
  const existingPlan = await db
    .select()
    .from(organizationPlans)
    .where(eq(organizationPlans.organizationId, targetOrgId))
    .limit(1);

  if (existingPlan.length && !parsed.explicitOverwrite) {
    const err: any = new Error("Target org already exists. Refusing to overwrite without explicitOverwrite=true.");
    err.status = 409;
    throw err;
  }

  // Minimal import: templates/entities/rows/mappings + inspections/responses + file metadata (no binaries)
  const mapTemplate = new Map<string, string>();
  const mapEntity = new Map<string, string>();
  const mapRow = new Map<string, string>();
  const mapInspection = new Map<string, string>();
  const mapFile = new Map<string, string>();

  // Create/Upsert plan+usage for target org
  const planKey = (manifest?.plan?.plan ?? "free") as any;

  await db.insert(organizationPlans).values({
    organizationId: targetOrgId,
    plan: planKey,
    createdAt: new Date(),
    updatedAt: new Date(),
  }).onConflictDoUpdate({
    target: organizationPlans.organizationId,
    set: { plan: planKey, updatedAt: new Date() },
  });

  await db.insert(organizationUsage).values({
    organizationId: targetOrgId,
    jobsThisMonth: manifest?.usage?.jobsThisMonth ?? 0,
    jobsMonthKey: manifest?.usage?.jobsMonthKey ?? "1970-01",
    totalTemplates: 0,
    totalEntities: 0,
    storageBytes: 0,
    updatedAt: new Date(),
  }).onConflictDoUpdate({
    target: organizationUsage.organizationId,
    set: {
      jobsThisMonth: manifest?.usage?.jobsThisMonth ?? 0,
      jobsMonthKey: manifest?.usage?.jobsMonthKey ?? "1970-01",
      updatedAt: new Date(),
    },
  });

  // Templates
  for (const t of (manifest?.templates ?? [])) {
    const newId = newUuid();
    mapTemplate.set(t.id, newId);
    await db.insert(formTemplates).values({
      id: newId,
      organizationId: targetOrgId,
      name: t.name,
      description: t.description ?? null,
      isActive: !!t.isActive,
      archivedAt: t.archivedAt ?? null,
      createdAt: t.createdAt ? new Date(t.createdAt) : new Date(),
      updatedAt: t.updatedAt ? new Date(t.updatedAt) : new Date(),
    });
  }

  // Entities
  for (const e of (manifest?.entities ?? [])) {
    const newId = newUuid();
    mapEntity.set(e.id, newId);
    await db.insert(entities).values({
      id: newId,
      organizationId: targetOrgId,
      title: e.title,
      description: e.description ?? null,
      archivedAt: e.archivedAt ?? null,
      createdAt: e.createdAt ? new Date(e.createdAt) : new Date(),
      updatedAt: e.updatedAt ? new Date(e.updatedAt) : new Date(),
    });
  }

  // EntityRows
  for (const r of (manifest?.entityRows ?? [])) {
    const newId = newUuid();
    mapRow.set(r.id, newId);
    await db.insert(entityRows).values({
      id: newId,
      organizationId: targetOrgId,
      entityId: mapEntity.get(r.entityId) ?? null,
      sortOrder: r.sortOrder ?? 0,
      component: r.component,
      activity: r.activity,
      reference: r.reference ?? null,
      fieldType: r.fieldType,
      units: r.units ?? null,
      choices: r.choices ?? null,
      evidenceRequired: !!r.evidenceRequired,
      archivedAt: r.archivedAt ?? null,
      createdAt: r.createdAt ? new Date(r.createdAt) : new Date(),
      updatedAt: r.updatedAt ? new Date(r.updatedAt) : new Date(),
    });
  }

  // TemplateEntities
  for (const m of (manifest?.templateEntities ?? [])) {
    const tid = mapTemplate.get(m.templateId);
    const eid = mapEntity.get(m.entityId);
    if (!tid || !eid) continue;
    await db.insert(formTemplateEntities).values({
      organizationId: targetOrgId,
      templateId: tid,
      entityId: eid,
      sortOrder: m.sortOrder ?? 0,
    });
  }

  // TemplateSystemTypes (systemTypeId assumed globally valid)
  for (const m of (manifest?.templateSystemTypes ?? [])) {
    const tid = mapTemplate.get(m.templateId);
    if (!tid) continue;
    await db.insert(formTemplateSystemTypes).values({
      organizationId: targetOrgId,
      templateId: tid,
      systemTypeId: m.systemTypeId,
    });
  }

  // Inspections (jobId preserved; if you want job remap, do Phase 12.1)
  for (const insp of (manifest?.inspections ?? [])) {
    const newId = newUuid();
    mapInspection.set(insp.id, newId);
    await db.insert(inspectionInstances).values({
      id: newId,
      organizationId: targetOrgId,
      jobId: insp.jobId,
      templateId: mapTemplate.get(insp.templateId) ?? null,
      systemTypeId: insp.systemTypeId,
      createdByUserId: args.auth.userId,
      completedAt: insp.completedAt ? new Date(insp.completedAt) : null,
      createdAt: insp.createdAt ? new Date(insp.createdAt) : new Date(),
    });
  }

  // Responses
  for (const r of (manifest?.inspectionResponses ?? [])) {
    const iid = mapInspection.get(r.inspectionId);
    const rid = mapRow.get(r.rowId);
    if (!iid || !rid) continue;

    await db.insert(inspectionResponses).values({
      id: newUuid(),
      organizationId: targetOrgId,
      inspectionId: iid,
      rowId: rid,
      valueText: r.valueText ?? null,
      valueNumber: r.valueNumber ?? null,
      valueBool: r.valueBool ?? null,
      comment: r.comment ?? null,
      createdByUserId: args.auth.userId,
      createdAt: r.createdAt ? new Date(r.createdAt) : new Date(),
    });
  }

  // File metadata (NO binaries)
  for (const f of (manifest?.files ?? [])) {
    const newId = newUuid();
    mapFile.set(f.id, newId);
    await db.insert(files).values({
      id: newId,
      organizationId: targetOrgId,
      storage: f.storage ?? "local",
      path: f.path,
      originalName: f.originalName,
      mimeType: f.mimeType ?? null,
      sizeBytes: Number(f.sizeBytes || 0),
      createdByUserId: args.auth.userId,
      createdAt: f.createdAt ? new Date(f.createdAt) : new Date(),
    });
  }

  // Attachments mapping
  for (const a of (manifest?.inspectionRowAttachments ?? [])) {
    const iid = mapInspection.get(a.inspectionId);
    const rid = mapRow.get(a.rowId);
    const fid = mapFile.get(a.fileId);
    if (!iid || !rid || !fid) continue;

    await db.insert(inspectionRowAttachments).values({
      id: newUuid(),
      organizationId: targetOrgId,
      inspectionId: iid,
      rowId: rid,
      fileId: fid,
      createdByUserId: args.auth.userId,
      createdAt: a.createdAt ? new Date(a.createdAt) : new Date(),
    });
  }

  // Update usage totals
  const totalTemplates = (manifest?.templates?.length ?? 0);
  const totalEntities = (manifest?.entities?.length ?? 0);
  const storageBytes = (manifest?.files ?? []).reduce((sum: number, f: any) => sum + Number(f.sizeBytes || 0), 0);

  await db.update(organizationUsage).set({
    totalTemplates,
    totalEntities,
    storageBytes,
    updatedAt: new Date(),
  }).where(eq(organizationUsage.organizationId, targetOrgId));

  // Audit event
  await logAudit(db, {
    organizationId: targetOrgId,
    actorUserId: args.auth.userId,
    action: "org.imported",
    entityType: "organization",
    entityId: targetOrgId,
    metadata: {
      sourceOrganizationId: sourceOrgId,
      counts: { totalTemplates, totalEntities, storageBytes },
    },
  });

  // Optional importRuns record
  try {
    await db.insert(importRuns).values({
      organizationId: targetOrgId,
      sourceOrganizationId: sourceOrgId,
      mode: "apply",
      status: "succeeded",
      summary: {
        sourceOrganizationId: sourceOrgId,
        totalTemplates,
        totalEntities,
        storageBytes,
      },
      createdByUserId: args.auth.userId,
    });
  } catch {}

  return {
    ok: true,
    targetOrgId,
    sourceOrganizationId: sourceOrgId,
    totals: { totalTemplates, totalEntities, storageBytes },
    note: "This server import restores metadata only. Use ZIP/CLI restore to restore attachment binaries.",
  };
}

////////////////////////////////////////////////////////////////
// C) server/routes.ts — ADD IMPORT ENDPOINT
////////////////////////////////////////////////////////////////

/*
Add imports:
import { dryRunImport, applyImport, ImportPayloadSchema } from "./lib/importOrg";
import { z } from "zod";

Paste inside apiRouter:
*/

apiRouter.post("/admin/import", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner"]); // owner only (safer)
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  // validate request shape
  const Body = ImportPayloadSchema;
  const parsed = Body.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ message: "Invalid payload", issues: parsed.error.issues });

  const mode = parsed.data.mode;

  try {
    if (mode === "dry_run") {
      const summary = await dryRunImport(db, parsed.data);
      try {
        await db.insert(importRuns).values({
          organizationId: auth.organizationId,
          sourceOrganizationId: summary.sourceOrganizationId,
          mode: "dry_run",
          status: "succeeded",
          summary,
          createdByUserId: auth.userId,
        });
      } catch {}
      return res.json({ ok: true, summary });
    }

    // apply
    const result = await applyImport(db, { auth: { organizationId: auth.organizationId, userId: auth.userId }, payload: parsed.data });
    return res.json(result);
  } catch (e: any) {
    const status = Number(e?.status || 500);
    try {
      await db.insert(importRuns).values({
        organizationId: auth.organizationId,
        sourceOrganizationId: req.body?.manifest?.organizationId ?? null,
        mode,
        status: "failed",
        error: String(e?.message || e),
        summary: {},
        createdByUserId: auth.userId,
      });
    } catch {}
    return res.status(status).json({ message: String(e?.message || "Import failed") });
  }
});

/*
DONE.

HOW TO USE (POSTMAN/Insomnia)
DRY RUN:
POST /api/admin/import
{
  "mode": "dry_run",
  "manifest": { ...copy of export manifest json... }
}

APPLY INTO NEW ORG (default):
POST /api/admin/import
{
  "mode": "apply",
  "manifest": { ... },
  "targetOrgId": "optional-uuid",
  "explicitOverwrite": false
}

If you want Phase 12.1 (import ZIP directly, incl binaries) — say: “12.1 ZIP import endpoint”
*/