/*
PATCH PHASE 12 SAFETY — MAKE IMPORT SAFE-BY-DEFAULT (ONE COPYABLE BLOCK)

WHAT THIS PATCH DOES
1) Apply mode now defaults to importing into a NEW orgId (auto-generated) unless targetOrgId provided.
2) Blocks importing into an existing org unless:
   - explicitOverwrite=true AND confirm === "IMPORT_OVERWRITE"
3) Adds allowOrphanInspections flag (default false):
   - If jobs aren’t restored and jobId would be null, inspections are SKIPPED unless allowOrphanInspections=true.
4) Improves response payload with skipped counts + warnings.

FILES TO UPDATE:
- server/lib/importOrg.ts
- server/routes.ts

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1) server/lib/importOrg.ts (PATCH / REPLACE CONTENTS OF FILE)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
*/

import { z } from "zod";
import crypto from "crypto";
import { eq } from "drizzle-orm";
import { logAudit } from "./audit";
import {
  organizationPlans,
  organizationUsage,
  formTemplates,
  entities,
  entityRows,
  formTemplateEntities,
  formTemplateSystemTypes,
  inspectionInstances,
  inspectionResponses,
  inspectionRowAttachments,
  files,
  importRuns,
} from "../shared/schema";

export const ImportPayloadSchema = z.object({
  manifest: z.any(),

  mode: z.enum(["dry_run", "apply"]),

  // Target org behaviour:
  // - If omitted in apply => server generates a new UUID
  targetOrgId: z.string().uuid().optional(),

  // Overwrite protection:
  explicitOverwrite: z.boolean().optional().default(false),
  confirm: z.string().optional(), // must be "IMPORT_OVERWRITE" when overwriting

  // If jobs aren’t restored, inspections become orphans.
  // Default false: skip inspections unless caller opts in.
  allowOrphanInspections: z.boolean().optional().default(false),

  // For future expansion
  includeJobs: z.boolean().optional().default(false),
});

function countArr(x: any) {
  return Array.isArray(x) ? x.length : 0;
}
function newUuid() {
  return crypto.randomUUID();
}

export async function dryRunImport(_db: any, source: any) {
  const m = source?.manifest ?? source;

  const summary = {
    sourceOrganizationId: m?.organizationId ?? null,
    exportedAt: m?.exportedAt ?? null,
    counts: {
      templates: countArr(m?.templates),
      entities: countArr(m?.entities),
      entityRows: countArr(m?.entityRows),
      templateEntities: countArr(m?.templateEntities),
      templateSystemTypes: countArr(m?.templateSystemTypes),
      inspections: countArr(m?.inspections),
      inspectionResponses: countArr(m?.inspectionResponses),
      files: countArr(m?.files),
      inspectionRowAttachments: countArr(m?.inspectionRowAttachments),
      jobs: countArr(m?.jobs),
      users: countArr(m?.users),
    },
    warnings: [] as string[],
  };

  if (summary.counts.jobs > 0) {
    summary.warnings.push(
      "Jobs exist in export. Server import does not restore jobs by default. Inspections may be skipped unless allowOrphanInspections=true."
    );
  }
  if (summary.counts.files > 0) {
    summary.warnings.push("Server import restores file metadata only. Use ZIP/CLI restore for attachment binaries.");
  }
  if (!Array.isArray(m?.templates)) summary.warnings.push("No templates[] found — export may be incomplete.");

  return summary;
}

export async function applyImport(db: any, args: {
  auth: { userId: string };
  payload: unknown;
}) {
  const parsed = ImportPayloadSchema.parse(args.payload);
  const manifest = (parsed as any).manifest;

  const sourceOrgId = manifest?.organizationId ?? null;

  // SAFE DEFAULT: import into NEW org unless explicitly provided
  const targetOrgId = parsed.targetOrgId ?? newUuid();

  // Check if target org already exists (plan row is our “org exists” signal)
  const existingPlan = await db
    .select()
    .from(organizationPlans)
    .where(eq(organizationPlans.organizationId, targetOrgId))
    .limit(1);

  if (existingPlan.length) {
    // Only allowed with explicitOverwrite + confirm
    if (!(parsed.explicitOverwrite && parsed.confirm === "IMPORT_OVERWRITE")) {
      const err: any = new Error(
        "Target org already exists. Refusing to import without explicitOverwrite=true and confirm=\"IMPORT_OVERWRITE\"."
      );
      err.status = 409;
      throw err;
    }
  }

  // Determine whether we can import inspections safely
  const jobsInExport = countArr(manifest?.jobs) > 0;
  const willOrphanInspections = true; // since jobs are not restored here

  const skipped = {
    inspections: 0,
    responses: 0,
    attachments: 0,
  };

  const warnings: string[] = [];
  if (willOrphanInspections && !parsed.allowOrphanInspections) {
    warnings.push(
      "Inspections were skipped because jobs are not restored via this endpoint. Set allowOrphanInspections=true to import them with jobId=null."
    );
  }

  // ID maps
  const mapTemplate = new Map<string, string>();
  const mapEntity = new Map<string, string>();
  const mapRow = new Map<string, string>();
  const mapInspection = new Map<string, string>();
  const mapFile = new Map<string, string>();

  // Plan + usage upsert for target org
  const planKey = (manifest?.plan?.plan ?? "free") as any;

  await db.insert(organizationPlans).values({
    organizationId: targetOrgId,
    plan: planKey,
    createdAt: new Date(),
    updatedAt: new Date(),
  }).onConflictDoUpdate({
    target: organizationPlans.organizationId,
    set: { plan: planKey, updatedAt: new Date() },
  });

  await db.insert(organizationUsage).values({
    organizationId: targetOrgId,
    jobsThisMonth: manifest?.usage?.jobsThisMonth ?? 0,
    jobsMonthKey: manifest?.usage?.jobsMonthKey ?? "1970-01",
    totalTemplates: 0,
    totalEntities: 0,
    storageBytes: 0,
    updatedAt: new Date(),
  }).onConflictDoUpdate({
    target: organizationUsage.organizationId,
    set: {
      jobsThisMonth: manifest?.usage?.jobsThisMonth ?? 0,
      jobsMonthKey: manifest?.usage?.jobsMonthKey ?? "1970-01",
      updatedAt: new Date(),
    },
  });

  // Templates
  for (const t of (manifest?.templates ?? [])) {
    const newId = newUuid();
    mapTemplate.set(t.id, newId);
    await db.insert(formTemplates).values({
      id: newId,
      organizationId: targetOrgId,
      name: t.name,
      description: t.description ?? null,
      isActive: !!t.isActive,
      archivedAt: t.archivedAt ?? null,
      createdAt: t.createdAt ? new Date(t.createdAt) : new Date(),
      updatedAt: t.updatedAt ? new Date(t.updatedAt) : new Date(),
    });
  }

  // Entities
  for (const e of (manifest?.entities ?? [])) {
    const newId = newUuid();
    mapEntity.set(e.id, newId);
    await db.insert(entities).values({
      id: newId,
      organizationId: targetOrgId,
      title: e.title,
      description: e.description ?? null,
      archivedAt: e.archivedAt ?? null,
      createdAt: e.createdAt ? new Date(e.createdAt) : new Date(),
      updatedAt: e.updatedAt ? new Date(e.updatedAt) : new Date(),
    });
  }

  // Rows
  for (const r of (manifest?.entityRows ?? [])) {
    const newId = newUuid();
    mapRow.set(r.id, newId);
    const mappedEntityId = mapEntity.get(r.entityId);
    if (!mappedEntityId) continue;

    await db.insert(entityRows).values({
      id: newId,
      organizationId: targetOrgId,
      entityId: mappedEntityId,
      sortOrder: r.sortOrder ?? 0,
      component: r.component,
      activity: r.activity,
      reference: r.reference ?? null,
      fieldType: r.fieldType,
      units: r.units ?? null,
      choices: r.choices ?? null,
      evidenceRequired: !!r.evidenceRequired,
      archivedAt: r.archivedAt ?? null,
      createdAt: r.createdAt ? new Date(r.createdAt) : new Date(),
      updatedAt: r.updatedAt ? new Date(r.updatedAt) : new Date(),
    });
  }

  // Mappings
  for (const m of (manifest?.templateEntities ?? [])) {
    const tid = mapTemplate.get(m.templateId);
    const eid = mapEntity.get(m.entityId);
    if (!tid || !eid) continue;
    await db.insert(formTemplateEntities).values({
      organizationId: targetOrgId,
      templateId: tid,
      entityId: eid,
      sortOrder: m.sortOrder ?? 0,
    });
  }

  for (const m of (manifest?.templateSystemTypes ?? [])) {
    const tid = mapTemplate.get(m.templateId);
    if (!tid) continue;
    await db.insert(formTemplateSystemTypes).values({
      organizationId: targetOrgId,
      templateId: tid,
      systemTypeId: m.systemTypeId,
    });
  }

  // Files metadata only (no binaries)
  for (const f of (manifest?.files ?? [])) {
    const newId = newUuid();
    mapFile.set(f.id, newId);
    await db.insert(files).values({
      id: newId,
      organizationId: targetOrgId,
      storage: f.storage ?? "local",
      path: f.path,
      originalName: f.originalName,
      mimeType: f.mimeType ?? null,
      sizeBytes: Number(f.sizeBytes || 0),
      createdByUserId: args.auth.userId,
      createdAt: f.createdAt ? new Date(f.createdAt) : new Date(),
    });
  }

  // Inspections + Responses + Attachments (conditionally)
  const importInspections = parsed.allowOrphanInspections;

  if (!importInspections) {
    skipped.inspections = countArr(manifest?.inspections);
    skipped.responses = countArr(manifest?.inspectionResponses);
    skipped.attachments = countArr(manifest?.inspectionRowAttachments);
  } else {
    // Inspections with jobId=null (or keep if present but not guaranteed)
    for (const insp of (manifest?.inspections ?? [])) {
      const newId = newUuid();
      mapInspection.set(insp.id, newId);

      await db.insert(inspectionInstances).values({
        id: newId,
        organizationId: targetOrgId,
        jobId: null, // orphan-safe
        templateId: mapTemplate.get(insp.templateId) ?? null,
        systemTypeId: insp.systemTypeId,
        createdByUserId: args.auth.userId,
        completedAt: insp.completedAt ? new Date(insp.completedAt) : null,
        createdAt: insp.createdAt ? new Date(insp.createdAt) : new Date(),
      });
    }

    for (const r of (manifest?.inspectionResponses ?? [])) {
      const iid = mapInspection.get(r.inspectionId);
      const rid = mapRow.get(r.rowId);
      if (!iid || !rid) continue;

      await db.insert(inspectionResponses).values({
        id: newUuid(),
        organizationId: targetOrgId,
        inspectionId: iid,
        rowId: rid,
        valueText: r.valueText ?? null,
        valueNumber: r.valueNumber ?? null,
        valueBool: r.valueBool ?? null,
        comment: r.comment ?? null,
        createdByUserId: args.auth.userId,
        createdAt: r.createdAt ? new Date(r.createdAt) : new Date(),
      });
    }

    for (const a of (manifest?.inspectionRowAttachments ?? [])) {
      const iid = mapInspection.get(a.inspectionId);
      const rid = mapRow.get(a.rowId);
      const fid = mapFile.get(a.fileId);
      if (!iid || !rid || !fid) continue;

      await db.insert(inspectionRowAttachments).values({
        id: newUuid(),
        organizationId: targetOrgId,
        inspectionId: iid,
        rowId: rid,
        fileId: fid,
        createdByUserId: args.auth.userId,
        createdAt: a.createdAt ? new Date(a.createdAt) : new Date(),
      });
    }
  }

  // Update usage totals
  const totalTemplates = countArr(manifest?.templates);
  const totalEntities = countArr(manifest?.entities);
  const storageBytes = (manifest?.files ?? []).reduce((sum: number, f: any) => sum + Number(f.sizeBytes || 0), 0);

  await db.update(organizationUsage).set({
    totalTemplates,
    totalEntities,
    storageBytes,
    updatedAt: new Date(),
  }).where(eq(organizationUsage.organizationId, targetOrgId));

  // Audit event
  await logAudit(db, {
    organizationId: targetOrgId,
    actorUserId: args.auth.userId,
    action: "org.imported",
    entityType: "organization",
    entityId: targetOrgId,
    metadata: {
      sourceOrganizationId: sourceOrgId,
      warnings,
      skipped,
      totals: { totalTemplates, totalEntities, storageBytes },
    },
  });

  // import_runs record
  try {
    await db.insert(importRuns).values({
      organizationId: targetOrgId,
      sourceOrganizationId: sourceOrgId,
      mode: "apply",
      status: "succeeded",
      summary: { warnings, skipped, totals: { totalTemplates, totalEntities, storageBytes } },
      createdByUserId: args.auth.userId,
    });
  } catch {}

  return {
    ok: true,
    targetOrgId,
    sourceOrganizationId: sourceOrgId,
    warnings,
    skipped,
    totals: { totalTemplates, totalEntities, storageBytes },
    note: "Server import restores metadata only. Use ZIP/CLI restore to restore attachment binaries.",
  };
}

/*
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2) server/routes.ts (PATCH) — enforce safety rules at the endpoint
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

REPLACE your existing POST /api/admin/import handler with this version.
*/

apiRouter.post("/admin/import", async (req, res) => {
  const auth = await requireOrgRole(req, ["owner"]); // keep owner-only for safety
  if (!auth.ok) return res.status(auth.status).json({ message: auth.message });

  const parsed = ImportPayloadSchema.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ message: "Invalid payload", issues: parsed.error.issues });
  }

  try {
    if (parsed.data.mode === "dry_run") {
      const summary = await dryRunImport(db, parsed.data);
      try {
        await db.insert(importRuns).values({
          organizationId: auth.organizationId,
          sourceOrganizationId: summary.sourceOrganizationId,
          mode: "dry_run",
          status: "succeeded",
          summary,
          createdByUserId: auth.userId,
        });
      } catch {}
      return res.json({ ok: true, summary });
    }

    // APPLY: safe-by-default behaviour is implemented inside applyImport
    const result = await applyImport(db, { auth: { userId: auth.userId }, payload: parsed.data });
    return res.json(result);
  } catch (e: any) {
    const status = Number(e?.status || 500);
    try {
      await db.insert(importRuns).values({
        organizationId: auth.organizationId,
        sourceOrganizationId: req.body?.manifest?.organizationId ?? null,
        mode: parsed.data.mode,
        status: "failed",
        error: String(e?.message || e),
        summary: {},
        createdByUserId: auth.userId,
      });
    } catch {}
    return res.status(status).json({ message: String(e?.message || "Import failed") });
  }
});

/*
USAGE NOTES
- APPLY into a NEW org (default):
  POST /api/admin/import
  {
    "mode":"apply",
    "manifest": { ... }
  }

- APPLY into specific NEW org:
  {
    "mode":"apply",
    "targetOrgId":"<new uuid>",
    "manifest":{...}
  }

- OVERWRITE existing org (NOT recommended):
  {
    "mode":"apply",
    "targetOrgId":"<existing org uuid>",
    "explicitOverwrite": true,
    "confirm": "IMPORT_OVERWRITE",
    "manifest":{...}
  }

- Import inspections as orphans (jobId=null):
  { ..., "allowOrphanInspections": true }

DONE.
*/ 